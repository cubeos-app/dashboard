# =============================================================================
# CubeOS Dashboard Pipeline - Build, Package, Deploy
# =============================================================================
#
# DEPLOY STRATEGY (single-node Swarm + host-mode networking):
#   - network_mode: host = only ONE container can bind port 6011 at a time
#   - Use stop-first update order (stop old, THEN start new)
#   - ~5s downtime during swap - unavoidable on single-node host-mode
#   - Auto-rollback if new container fails health checks
#
# =============================================================================

stages:
  - build
  - package
  - deploy

variables:
  GHCR_IMAGE: "ghcr.io/cubeos-app/dashboard"
  BUILDER_IMAGE: "ghcr.io/cubeos-app/dashboard-builder"
  SERVICE_NAME: "cubeos-dashboard_cubeos-dashboard"
  STACK_NAME: "cubeos-dashboard"
  COMPOSE_DIR: "/cubeos/coreapps/cubeos-dashboard/appconfig"
  HEALTH_URL: "http://127.0.0.1:6011/"
  CONVERGE_TIMEOUT: "180"
  HEALTH_TIMEOUT: "90"

# -----------------------------------------------------------------------------
# BUILD - Build static files (for MR validation)
# -----------------------------------------------------------------------------
build:
  stage: build
  tags: [multiarch]
  image: node:20-alpine
  script:
    - npm ci
    - npm run build
    - ls -la dist/
  artifacts:
    paths:
      - dist/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# -----------------------------------------------------------------------------
# PACKAGE - Build multi-arch Docker image
# -----------------------------------------------------------------------------
package:
  stage: package
  tags: [multiarch]
  image: docker:24
  before_script:
    - echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
    - docker buildx create --name mybuilder --driver docker-container --use 2>/dev/null || docker buildx use mybuilder
    - docker buildx inspect --bootstrap
  script:
    - echo "Building dashboard image..."
    - >-
      docker buildx build
      --platform linux/amd64,linux/arm64
      --build-arg BUILDER_IMAGE=${BUILDER_IMAGE}:latest
      --push
      -t ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}
      -t ${GHCR_IMAGE}:latest
      .
    - echo "Pushed ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}"
  after_script:
    - docker buildx rm mybuilder 2>/dev/null || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# -----------------------------------------------------------------------------
# DEPLOY - Swarm deploy with stop-first + auto-rollback
# -----------------------------------------------------------------------------
deploy:
  stage: deploy
  tags: [arm64, cubeos, deploy]
  before_script:
    - echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
  script:
    # === PRE-FLIGHT CHECKS ===
    - |
      echo "=== Pre-flight checks ==="
      if ! docker info --format '{{.Swarm.LocalNodeState}}' | grep -q "active"; then
        echo "FATAL: Docker Swarm is not active"
        exit 1
      fi
      echo "  Swarm: active"
      if [ ! -f "${COMPOSE_DIR}/docker-compose.yml" ]; then
        echo "FATAL: ${COMPOSE_DIR}/docker-compose.yml not found"
        exit 1
      fi
      echo "  Compose file: found"

    # === PULL IMAGE ===
    - |
      echo "=== Pulling image ==="
      docker pull ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}
      docker tag ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA} ${GHCR_IMAGE}:latest
      echo "  Image ready: ${CI_COMMIT_SHORT_SHA}"

    # === DEPLOY ===
    # Use ONE update path only - never stack deploy + service update together.
    # If service exists: service update (changes image, triggers stop-first).
    # If service doesn't exist: stack deploy (creates everything from scratch).
    - |
      echo "=== Deploying ==="
      if docker service inspect ${SERVICE_NAME} >/dev/null 2>&1; then
        echo "  Service exists - updating image (stop-first)..."
        docker service update \
          --image ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA} \
          --update-order stop-first \
          --update-failure-action rollback \
          --detach \
          ${SERVICE_NAME}
        echo "  Update triggered"
      else
        echo "  Service not found - creating via stack deploy..."
        cd ${COMPOSE_DIR}
        docker stack deploy \
          --compose-file docker-compose.yml \
          --resolve-image never \
          ${STACK_NAME}
        echo "  Stack created"
      fi

    # === WAIT FOR SWARM CONVERGENCE ===
    # Disable set -e for the polling loop - transient states cause
    # non-zero exits from grep/docker that would kill the script.
    - |
      echo "=== Waiting for convergence (max ${CONVERGE_TIMEOUT}s) ==="
      set +e
      ELAPSED=0
      CONVERGED=0
      while [ $ELAPSED -lt ${CONVERGE_TIMEOUT} ]; do
        STATE=$(docker service ps ${SERVICE_NAME} \
          --filter "desired-state=running" \
          --format "{{.CurrentState}}" 2>/dev/null | head -1)

        case "$STATE" in
          Running*)
            echo "  Converged: ${STATE} (${ELAPSED}s)"
            CONVERGED=1
            break
            ;;
          Failed*|Rejected*|Orphaned*)
            echo "  WARNING: ${STATE} (${ELAPSED}s)"
            ROLLBACK=$(docker service inspect ${SERVICE_NAME} \
              --format '{{.UpdateStatus.State}}' 2>/dev/null || echo "unknown")
            if [ "$ROLLBACK" = "rollback_completed" ]; then
              echo "  ROLLBACK completed - new image failed, reverted"
              docker service ps ${SERVICE_NAME} --no-trunc 2>/dev/null
              set -e
              exit 1
            fi
            ;;
          "")
            echo "  Waiting for task scheduling... (${ELAPSED}s)"
            ;;
          *)
            echo "  ${STATE} (${ELAPSED}s)"
            ;;
        esac

        sleep 3
        ELAPSED=$((ELAPSED + 3))
      done
      set -e

      if [ "$CONVERGED" -ne 1 ]; then
        echo "ERROR: Did not converge within ${CONVERGE_TIMEOUT}s"
        docker service ps ${SERVICE_NAME} --no-trunc 2>/dev/null || true
        docker service logs ${SERVICE_NAME} --tail 30 2>/dev/null || true
        echo "Triggering rollback..."
        docker service update --rollback ${SERVICE_NAME} 2>/dev/null || true
        exit 1
      fi

    # === HTTP HEALTH CHECK ===
    - |
      echo "=== HTTP health check (max ${HEALTH_TIMEOUT}s) ==="
      set +e
      ELAPSED=0
      HEALTHY=0
      while [ $ELAPSED -lt ${HEALTH_TIMEOUT} ]; do
        HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" ${HEALTH_URL} 2>/dev/null || echo "000")
        if [ "$HTTP_CODE" = "200" ]; then
          echo "  HTTP 200 OK (${ELAPSED}s)"
          HEALTHY=1
          break
        fi
        echo "  HTTP ${HTTP_CODE} (${ELAPSED}s)"
        sleep 3
        ELAPSED=$((ELAPSED + 3))
      done
      set -e

      if [ "$HEALTHY" -ne 1 ]; then
        echo "ERROR: Health check failed after ${HEALTH_TIMEOUT}s"
        echo "Triggering rollback..."
        docker service update --rollback ${SERVICE_NAME} 2>/dev/null || true
        docker service ps ${SERVICE_NAME} --no-trunc 2>/dev/null || true
        docker service logs ${SERVICE_NAME} --tail 50 2>/dev/null || true
        exit 1
      fi

    # === VERIFY ===
    - |
      echo "=== Deployment verified ==="
      docker service ls --filter "name=${SERVICE_NAME}"
      RUNNING_IMAGE=$(docker service inspect ${SERVICE_NAME} \
        --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}' 2>/dev/null || echo "unknown")
      echo "  Image:     ${RUNNING_IMAGE}"
      echo "  Expected:  ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}"
      echo "  Dashboard: http://cubeos.cube"

    # === CLEANUP ===
    - |
      echo "=== Cleanup ==="
      docker image prune -f 2>/dev/null || true
      DISK_FREE=$(df -h / | awk 'NR==2{print $4}')
      echo "  Disk free: ${DISK_FREE}"
      echo "=== Deploy complete ==="

  environment:
    name: production
    url: http://cubeos.cube
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
