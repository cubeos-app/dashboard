# =============================================================================
# CubeOS Dashboard Pipeline - Build, Package, Deploy
# =============================================================================
#
# DEPLOY STRATEGY (single-node Swarm + host-mode port):
#   - Port 6011 in host mode = only ONE container can bind it
#   - stop-first update order (stop old THEN start new)
#   - Pre-pulled image: docker pull before any service changes
#   - Self-healing: detects stuck services and auto-recovers
#   - ~5s downtime during swap - unavoidable on single-node host-mode
#
# =============================================================================

stages:
  - build
  - package
  - deploy

variables:
  GHCR_IMAGE: "ghcr.io/cubeos-app/dashboard"
  BUILDER_IMAGE: "ghcr.io/cubeos-app/dashboard-builder"
  SERVICE_NAME: "cubeos-dashboard_cubeos-dashboard"
  STACK_NAME: "cubeos-dashboard"
  COMPOSE_DIR: "/cubeos/coreapps/cubeos-dashboard/appconfig"
  HEALTH_URL: "http://127.0.0.1:6011/"
  CONVERGE_TIMEOUT: "180"
  HEALTH_TIMEOUT: "90"

# -----------------------------------------------------------------------------
# BUILD - Build static files (for MR validation)
# -----------------------------------------------------------------------------
build:
  stage: build
  tags: [multiarch]
  image: node:20-alpine
  script:
    - npm ci
    - npm run build
    - ls -la dist/
  artifacts:
    paths:
      - dist/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# -----------------------------------------------------------------------------
# PACKAGE - Build multi-arch Docker image
# -----------------------------------------------------------------------------
package:
  stage: package
  tags: [multiarch]
  image: docker:24
  before_script:
    - echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
    - docker buildx create --name mybuilder --driver docker-container --use 2>/dev/null || docker buildx use mybuilder
    - docker buildx inspect --bootstrap
  script:
    - echo "Building dashboard image..."
    - >-
      docker buildx build
      --platform linux/amd64,linux/arm64
      --build-arg BUILDER_IMAGE=${BUILDER_IMAGE}:latest
      --push
      -t ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}
      -t ${GHCR_IMAGE}:latest
      .
    - echo "Pushed ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}"
  after_script:
    - docker buildx rm mybuilder 2>/dev/null || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# -----------------------------------------------------------------------------
# DEPLOY - Self-healing Swarm deploy
# -----------------------------------------------------------------------------
deploy:
  stage: deploy
  tags: [arm64, cubeos, deploy]
  before_script:
    - echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
  script:
    # === PRE-FLIGHT ===
    - |
      echo "=== Pre-flight ==="
      if ! docker info --format '{{.Swarm.LocalNodeState}}' | grep -q "active"; then
        echo "FATAL: Docker Swarm not active"
        exit 1
      fi
      echo "  Swarm: active"
      if [ ! -f "${COMPOSE_DIR}/docker-compose.yml" ]; then
        echo "FATAL: ${COMPOSE_DIR}/docker-compose.yml not found"
        exit 1
      fi
      echo "  Compose file: found"

    # === PULL IMAGE ===
    - |
      echo "=== Pulling image ==="
      docker pull ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}
      docker tag ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA} ${GHCR_IMAGE}:latest
      echo "  Pulled and tagged: ${CI_COMMIT_SHORT_SHA}"
      docker image ls ${GHCR_IMAGE} --format "  {{.Tag}}\t{{.Size}}"

    # === DIAGNOSE SERVICE STATE ===
    - |
      echo "=== Service health check ==="
      DEPLOY_METHOD="create"

      if docker service inspect ${SERVICE_NAME} >/dev/null 2>&1; then
        RUNNING_COUNT=$(docker service ps ${SERVICE_NAME} \
          --filter "desired-state=running" \
          --format "{{.CurrentState}}" 2>/dev/null \
          | grep -c "Running" || echo "0")

        UPDATE_STATE=$(docker service inspect ${SERVICE_NAME} \
          --format '{{.UpdateStatus.State}}' 2>/dev/null || echo "none")

        REPLICAS=$(docker service ls --filter "name=${SERVICE_NAME}" \
          --format "{{.Replicas}}" 2>/dev/null || echo "0/0")

        echo "  Service exists"
        echo "  Replicas:      ${REPLICAS}"
        echo "  Running tasks: ${RUNNING_COUNT}"
        echo "  Update state:  ${UPDATE_STATE}"

        if [ "${RUNNING_COUNT}" -ge 1 ] && echo "${UPDATE_STATE}" | grep -qvE "updating|paused"; then
          DEPLOY_METHOD="update"
          echo "  Status: HEALTHY -> will update in-place"
        else
          DEPLOY_METHOD="recreate"
          echo "  Status: STUCK/BROKEN -> will destroy and recreate"
        fi
      else
        echo "  Service does not exist -> will create fresh"
      fi

    # === DEPLOY ===
    - |
      echo "=== Deploying (method: ${DEPLOY_METHOD}) ==="

      case "${DEPLOY_METHOD}" in
        update)
          # Happy path: service is healthy, update image with stop-first.
          # Image is already pulled locally; Swarm uses local store for
          # images that are already present - no registry access needed.
          # NOTE: --resolve-image is NOT supported on docker service update,
          #       only on docker stack deploy. Don't add it here.
          echo "  Updating service image..."
          docker service update \
            --image ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA} \
            --update-order stop-first \
            --update-failure-action rollback \
            --detach \
            ${SERVICE_NAME}
          echo "  Update triggered"
          ;;

        recreate)
          # Self-heal: service is stuck, destroy everything and start fresh
          echo "  Removing stuck stack..."
          docker stack rm ${STACK_NAME} 2>/dev/null || true

          # Wait for all containers to fully drain
          echo "  Waiting for full cleanup..."
          set +e
          WAIT=0
          while [ $WAIT -lt 30 ]; do
            REMAINING=$(docker ps -q --filter "label=com.docker.stack.namespace=${STACK_NAME}" 2>/dev/null | wc -l)
            if [ "$REMAINING" -eq 0 ]; then
              echo "  All containers gone after ${WAIT}s"
              break
            fi
            echo "  ${REMAINING} container(s) draining... (${WAIT}s)"
            sleep 2
            WAIT=$((WAIT + 2))
          done

          # Force-kill stragglers
          STRAGGLERS=$(docker ps -q --filter "label=com.docker.stack.namespace=${STACK_NAME}" 2>/dev/null)
          if [ -n "$STRAGGLERS" ]; then
            echo "  Force-killing stragglers..."
            echo "$STRAGGLERS" | xargs docker rm -f 2>/dev/null || true
            sleep 3
          fi
          set -e

          # Verify port 6011 is free before deploying
          if ss -tlnp 2>/dev/null | grep -q ":6011 "; then
            echo "  WARNING: port 6011 still bound, waiting 5s..."
            sleep 5
          fi

          echo "  Deploying fresh stack..."
          cd ${COMPOSE_DIR}
          docker stack deploy \
            --compose-file docker-compose.yml \
            --resolve-image never \
            ${STACK_NAME}
          echo "  Fresh stack deployed"
          ;;

        create)
          # First-ever deploy
          echo "  Creating stack..."
          cd ${COMPOSE_DIR}
          docker stack deploy \
            --compose-file docker-compose.yml \
            --resolve-image never \
            ${STACK_NAME}
          echo "  Stack created"
          ;;
      esac

    # === WAIT FOR CONVERGENCE ===
    - |
      echo "=== Waiting for convergence (max ${CONVERGE_TIMEOUT}s) ==="
      set +e
      ELAPSED=0
      CONVERGED=0
      while [ $ELAPSED -lt ${CONVERGE_TIMEOUT} ]; do
        STATE=$(docker service ps ${SERVICE_NAME} \
          --filter "desired-state=running" \
          --format "{{.CurrentState}}" 2>/dev/null | head -1)

        case "$STATE" in
          Running*)
            echo "  Converged: ${STATE} (${ELAPSED}s)"
            CONVERGED=1
            break
            ;;
          Failed*|Rejected*|Orphaned*)
            echo "  WARNING: ${STATE} (${ELAPSED}s)"
            ROLLBACK=$(docker service inspect ${SERVICE_NAME} \
              --format '{{.UpdateStatus.State}}' 2>/dev/null || echo "unknown")
            if [ "$ROLLBACK" = "rollback_completed" ]; then
              echo "  ROLLBACK detected - reverted to previous image"
              docker service ps ${SERVICE_NAME} --no-trunc 2>/dev/null
              set -e
              exit 1
            fi
            ;;
          "")
            echo "  Scheduling... (${ELAPSED}s)"
            ;;
          *)
            echo "  ${STATE} (${ELAPSED}s)"
            ;;
        esac

        sleep 3
        ELAPSED=$((ELAPSED + 3))
      done
      set -e

      if [ "$CONVERGED" -ne 1 ]; then
        echo "ERROR: Did not converge within ${CONVERGE_TIMEOUT}s"
        docker service ps ${SERVICE_NAME} --no-trunc 2>/dev/null || true
        docker service logs ${SERVICE_NAME} --tail 30 2>/dev/null || true
        docker service update --rollback ${SERVICE_NAME} 2>/dev/null || true
        exit 1
      fi

    # === HTTP HEALTH CHECK ===
    - |
      echo "=== HTTP health check (max ${HEALTH_TIMEOUT}s) ==="
      set +e
      ELAPSED=0
      HEALTHY=0
      while [ $ELAPSED -lt ${HEALTH_TIMEOUT} ]; do
        HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" ${HEALTH_URL} 2>/dev/null || echo "000")
        if [ "$HTTP_CODE" = "200" ]; then
          echo "  HTTP 200 OK (${ELAPSED}s)"
          HEALTHY=1
          break
        fi
        echo "  HTTP ${HTTP_CODE} (${ELAPSED}s)"
        sleep 3
        ELAPSED=$((ELAPSED + 3))
      done
      set -e

      if [ "$HEALTHY" -ne 1 ]; then
        echo "ERROR: Health check failed after ${HEALTH_TIMEOUT}s"
        docker service update --rollback ${SERVICE_NAME} 2>/dev/null || true
        docker service ps ${SERVICE_NAME} --no-trunc 2>/dev/null || true
        docker service logs ${SERVICE_NAME} --tail 50 2>/dev/null || true
        exit 1
      fi

    # === VERIFY IMAGE ACTUALLY CHANGED ===
    # This catches the case where the update silently failed but the
    # old container kept running, making health checks pass.
    - |
      echo "=== Verifying deployment ==="
      RUNNING_IMAGE=$(docker service inspect ${SERVICE_NAME} \
        --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}' 2>/dev/null)
      EXPECTED="${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}"

      echo "  Running: ${RUNNING_IMAGE}"
      echo "  Expected: ${EXPECTED}"

      if [ "${RUNNING_IMAGE}" != "${EXPECTED}" ]; then
        echo "  ERROR: Image mismatch! Update did not apply."
        echo "  Attempting forced recreate..."
        docker stack rm ${STACK_NAME} 2>/dev/null || true
        sleep 10
        cd ${COMPOSE_DIR}
        # Temporarily patch image in compose to use commit SHA
        # (compose file uses :latest, we need the specific SHA)
        docker stack deploy \
          --compose-file docker-compose.yml \
          --resolve-image never \
          ${STACK_NAME}
        # Then force the correct image
        sleep 5
        docker service update \
          --image ${EXPECTED} \
          --update-order stop-first \
          --update-failure-action rollback \
          --detach \
          ${SERVICE_NAME}
        # Wait for it
        sleep 15
        RETRY_IMAGE=$(docker service inspect ${SERVICE_NAME} \
          --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}' 2>/dev/null)
        if [ "${RETRY_IMAGE}" != "${EXPECTED}" ]; then
          echo "  FATAL: Forced recreate also failed"
          echo "  Running: ${RETRY_IMAGE}"
          docker service ps ${SERVICE_NAME} --no-trunc 2>/dev/null || true
          exit 1
        fi
        echo "  Recovered via forced recreate"
      fi

      echo "  Image verified"

    # === DONE ===
    - |
      echo "=== Deploy complete ==="
      docker service ls --filter "name=${SERVICE_NAME}"
      echo "  Dashboard: http://cubeos.cube"
      docker image prune -f 2>/dev/null || true
      df -h / | awk 'NR==2{printf "  Disk free: %s\n", $4}'

  environment:
    name: production
    url: http://cubeos.cube
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
