# =============================================================================
# CubeOS Dashboard Pipeline - Build, Package, Deploy
# =============================================================================
#
# DEPLOY STRATEGY:
#   Always: stack rm -> wait for drain -> stack deploy (with correct image)
#
#   Why not docker service update?
#     - Pi's Docker doesn't support --resolve-image on service update
#     - Without it, Swarm tries to verify image with GHCR during "Preparing"
#     - GHCR resolution is slow/flaky on Pi -> tasks fail -> Swarm rolls back
#     - Result: pipeline "succeeds" but old image is still running
#
#   Why stack rm -> stack deploy works:
#     - stack deploy supports --resolve-image never (uses local image)
#     - No old container = no port 6011 conflict
#     - ~10-15s downtime (same as stop-first would give)
#     - One code path, no edge cases
#
# =============================================================================

stages:
  - build
  - package
  - deploy

variables:
  GHCR_IMAGE: "ghcr.io/cubeos-app/dashboard"
  BUILDER_IMAGE: "ghcr.io/cubeos-app/dashboard-builder"
  SERVICE_NAME: "cubeos-dashboard_cubeos-dashboard"
  STACK_NAME: "cubeos-dashboard"
  COMPOSE_DIR: "/cubeos/coreapps/cubeos-dashboard/appconfig"
  HEALTH_URL: "http://127.0.0.1:6011/"
  CONVERGE_TIMEOUT: "120"
  HEALTH_TIMEOUT: "90"

# -----------------------------------------------------------------------------
# BUILD - Build static files (for MR validation)
# -----------------------------------------------------------------------------
build:
  stage: build
  tags: [multiarch]
  image: node:20-alpine
  script:
    - npm ci
    - npm run build
    - ls -la dist/
  artifacts:
    paths:
      - dist/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# -----------------------------------------------------------------------------
# PACKAGE - Build multi-arch Docker image
# -----------------------------------------------------------------------------
package:
  stage: package
  tags: [multiarch]
  image: docker:24
  before_script:
    - echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
    - docker buildx create --name mybuilder --driver docker-container --use 2>/dev/null || docker buildx use mybuilder
    - docker buildx inspect --bootstrap
  script:
    - echo "Building dashboard image..."
    - >-
      docker buildx build
      --platform linux/amd64,linux/arm64
      --build-arg BUILDER_IMAGE=${BUILDER_IMAGE}:latest
      --push
      -t ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}
      -t ${GHCR_IMAGE}:latest
      .
    - echo "Pushed ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}"
  after_script:
    - docker buildx rm mybuilder 2>/dev/null || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"

# -----------------------------------------------------------------------------
# DEPLOY
# -----------------------------------------------------------------------------
deploy:
  stage: deploy
  tags: [arm64, cubeos, deploy]
  before_script:
    - echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin
  script:
    # === PRE-FLIGHT ===
    - |
      echo "=== Pre-flight ==="
      if ! docker info --format '{{.Swarm.LocalNodeState}}' | grep -q "active"; then
        echo "FATAL: Docker Swarm not active"
        exit 1
      fi
      echo "  Swarm: active"
      if [ ! -f "${COMPOSE_DIR}/docker-compose.yml" ]; then
        echo "FATAL: ${COMPOSE_DIR}/docker-compose.yml not found"
        exit 1
      fi
      echo "  Compose: found"

    # === PULL IMAGE ===
    - |
      echo "=== Pulling image ==="
      docker pull ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}
      docker tag ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA} ${GHCR_IMAGE}:latest
      echo "  Ready: ${CI_COMMIT_SHORT_SHA}"

    # === PREPARE COMPOSE ===
    # Inject the exact commit SHA image tag into a temp copy of the compose.
    # The original compose uses :latest - we pin to the exact build.
    - |
      echo "=== Preparing compose ==="
      cp ${COMPOSE_DIR}/docker-compose.yml /tmp/deploy-compose.yml
      sed -i "s|image:.*dashboard.*|image: ${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}|" /tmp/deploy-compose.yml
      echo "  Image tag in compose:"
      grep "image:" /tmp/deploy-compose.yml | head -1

    # === REMOVE OLD STACK ===
    - |
      echo "=== Removing old stack ==="
      docker stack rm ${STACK_NAME} 2>/dev/null || true

      # Wait for all containers to drain and port to release
      set +e
      WAIT=0
      while [ $WAIT -lt 30 ]; do
        REMAINING=$(docker ps -q \
          --filter "label=com.docker.stack.namespace=${STACK_NAME}" \
          2>/dev/null | wc -l)
        if [ "$REMAINING" -eq 0 ]; then
          echo "  Drained in ${WAIT}s"
          break
        fi
        echo "  ${REMAINING} container(s) draining... (${WAIT}s)"
        sleep 2
        WAIT=$((WAIT + 2))
      done

      # Force-kill stragglers
      STRAGGLERS=$(docker ps -q \
        --filter "label=com.docker.stack.namespace=${STACK_NAME}" \
        2>/dev/null)
      if [ -n "$STRAGGLERS" ]; then
        echo "  Force-killing stragglers..."
        echo "$STRAGGLERS" | xargs docker rm -f 2>/dev/null || true
        sleep 3
      fi
      set -e

      # Verify port is free
      if ss -tlnp 2>/dev/null | grep -q ":6011 "; then
        echo "  Port 6011 still bound, waiting..."
        sleep 5
      fi
      echo "  Clean slate"

    # === DEPLOY FRESH STACK ===
    - |
      echo "=== Deploying stack ==="
      docker stack deploy \
        --compose-file /tmp/deploy-compose.yml \
        --resolve-image never \
        ${STACK_NAME}
      echo "  Stack deployed"

    # === WAIT FOR CONVERGENCE ===
    - |
      echo "=== Waiting for convergence (max ${CONVERGE_TIMEOUT}s) ==="
      set +e
      ELAPSED=0
      CONVERGED=0
      while [ $ELAPSED -lt ${CONVERGE_TIMEOUT} ]; do
        STATE=$(docker service ps ${SERVICE_NAME} \
          --filter "desired-state=running" \
          --format "{{.CurrentState}}" 2>/dev/null | head -1)

        case "$STATE" in
          Running*)
            echo "  Converged: ${STATE} (${ELAPSED}s)"
            CONVERGED=1
            break
            ;;
          "")
            echo "  Scheduling... (${ELAPSED}s)"
            ;;
          *)
            echo "  ${STATE} (${ELAPSED}s)"
            ;;
        esac

        sleep 3
        ELAPSED=$((ELAPSED + 3))
      done
      set -e

      if [ "$CONVERGED" -ne 1 ]; then
        echo "ERROR: Did not converge within ${CONVERGE_TIMEOUT}s"
        docker service ps ${SERVICE_NAME} --no-trunc 2>/dev/null || true
        docker service logs ${SERVICE_NAME} --tail 30 2>/dev/null || true
        exit 1
      fi

    # === HTTP HEALTH CHECK ===
    - |
      echo "=== HTTP health check (max ${HEALTH_TIMEOUT}s) ==="
      set +e
      ELAPSED=0
      HEALTHY=0
      while [ $ELAPSED -lt ${HEALTH_TIMEOUT} ]; do
        HTTP_CODE=$(curl -sf -o /dev/null -w "%{http_code}" ${HEALTH_URL} 2>/dev/null || echo "000")
        if [ "$HTTP_CODE" = "200" ]; then
          echo "  HTTP 200 OK (${ELAPSED}s)"
          HEALTHY=1
          break
        fi
        echo "  HTTP ${HTTP_CODE} (${ELAPSED}s)"
        sleep 3
        ELAPSED=$((ELAPSED + 3))
      done
      set -e

      if [ "$HEALTHY" -ne 1 ]; then
        echo "ERROR: Health check failed after ${HEALTH_TIMEOUT}s"
        docker service ps ${SERVICE_NAME} --no-trunc 2>/dev/null || true
        docker service logs ${SERVICE_NAME} --tail 50 2>/dev/null || true
        exit 1
      fi

    # === VERIFY IMAGE ===
    - |
      echo "=== Verifying ==="
      RUNNING_IMAGE=$(docker service inspect ${SERVICE_NAME} \
        --format '{{.Spec.TaskTemplate.ContainerSpec.Image}}' 2>/dev/null || echo "unknown")
      EXPECTED="${GHCR_IMAGE}:${CI_COMMIT_SHORT_SHA}"
      echo "  Running:  ${RUNNING_IMAGE}"
      echo "  Expected: ${EXPECTED}"
      if [ "${RUNNING_IMAGE}" != "${EXPECTED}" ]; then
        echo "  FATAL: Image mismatch after deploy!"
        exit 1
      fi
      echo "  Image verified"

    # === DONE ===
    - |
      echo "=== Deploy complete ==="
      docker service ls --filter "name=${SERVICE_NAME}"
      echo "  Dashboard: http://cubeos.cube"
      docker image prune -f 2>/dev/null || true
      df -h / | awk 'NR==2{printf "  Disk free: %s\n", $4}'

  environment:
    name: production
    url: http://cubeos.cube
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
      when: on_success
